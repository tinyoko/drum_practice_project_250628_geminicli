<!DOCTYPE html>
<html>
<head>
    <title>{{ song.title }} - Drum Practice</title>
    <script src="https://unpkg.com/wavesurfer.js@7/dist/wavesurfer.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.11.338/pdf.min.js"></script>
    <style>
        body { 
            font-family: sans-serif; 
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
        }
        #header-container {
            display: flex;
            align-items: center;
            width: 90%;
            margin-bottom: 20px;
        }
        h1 { 
            flex-grow: 1;
            text-align: center;
            margin: 0;
        }
        .return-button-container .button {
            display: inline-block;
            padding: 10px 20px;
            background-color: #007bff;
            color: white;
            text-decoration: none;
            border-radius: 5px;
            font-size: 1em;
        }
        .return-button-container .button:hover {
            background-color: #0056b3;
        }
        #waveform-container {
            width: 90%;
            margin-bottom: 20px;
        }
        #waveform {
            height: 128px;
        }
        .controls {
            text-align: center;
            margin-top: 10px;
        }
        #main-view-container {
            display: flex;
            gap: 20px;
            width: 90%;
            height: 70vh;
            margin-bottom: 20px;
        }
        #timings-section {
            flex: 0 0 280px; /* Slightly wider for table */
            border: 1px solid #ccc;
            padding: 15px;
            overflow-y: auto;
            height: 100%;
            box-sizing: border-box;
        }
        #timings-section h2 {
            margin-top: 0;
            font-size: 1.2em;
            text-align: center;
        }
        #timings-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.9em;
        }
        #timings-table th, #timings-table td {
            border: 1px solid #ddd;
            padding: 4px;
            text-align: center;
        }
        #timings-table th {
            background-color: #f2f2f2;
        }
        #timings-table button {
            width: 100%;
            padding: 5px;
            border: 1px solid #ccc;
            background-color: #f9f9f9;
            cursor: pointer;
        }
        #timings-table button:hover {
            background-color: #e0e0e0;
        }
        .status-unsaved {
            color: red;
            font-weight: bold;
        }
        #pdf-container { 
            flex: 1 1 auto;
            display: flex; 
            justify-content: center; 
            align-items: center;
            gap: 10px; 
            height: 100%;
            box-sizing: border-box;
        }
        canvas { 
            border: 1px solid black;
            display: none;
            max-width: calc(50% - 5px);
            max-height: 100%;
        }
    </style>
</head>
<body>
    <div id="header-container">
        <div class="return-button-container">
            <a href="{% url 'song_list' %}" class="button">Back to Song List</a>
        </div>
        <h1>{{ song.title }}</h1>
        <button id="play-pause" class="button">Play/Pause</button>
    </div>

    <div id="waveform-container">
        <div id="waveform"></div>
    </div>

    <div id="main-view-container">
        <!-- Timings Management -->
        <div id="timings-section">
            <h2>ページ開始時間</h2>
            <table id="timings-table">
                <thead>
                    <tr>
                        <th>ページ</th>
                        <th>開始時間</th>
                        <th>めくり設定</th>
                    </tr>
                </thead>
                <tbody>
                    <!-- Rows will be generated by JavaScript -->
                </tbody>
            </table>
        </div>

        <!-- PDF Viewer -->
        <div id="pdf-container">
            <canvas id="pdf-canvas-left"></canvas>
            <canvas id="pdf-canvas-right"></canvas>
        </div>
    </div>

    <script>
        // --- CSRF Token for Fetch ---
        const csrfToken = '{{ csrf_token }}';

        // --- DOM Elements ---
        const canvasLeft = document.getElementById('pdf-canvas-left');
        const canvasRight = document.getElementById('pdf-canvas-right');
        const ctxLeft = canvasLeft.getContext('2d');
        const ctxRight = canvasRight.getContext('2d');
        const timingsTableBody = document.querySelector('#timings-table tbody');

        // --- State ---
        const pdfUrl = "{{ score.pdf_file.url }}";
        // Server provides timings for page 2, 3, ...
        const serverTimings = {{ score.page_timings|safe }};
        let pageSettings = [];
        let pdfDoc = null;
        let currentPage = 1;

        // --- PDF.js Setup ---
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.11.338/pdf.worker.min.js';

        async function renderPage(pageNum, canvas, context) {
            if (!pdfDoc) return;
            const page = await pdfDoc.getPage(pageNum);
            const containerWidth = canvas.parentElement.clientWidth / 2 - 5;
            const containerHeight = canvas.parentElement.clientHeight;
            const viewport = page.getViewport({ scale: 1.0 });
            const scale = Math.min(containerWidth / viewport.width, containerHeight / viewport.height);
            const scaledViewport = page.getViewport({ scale: scale });
            canvas.height = scaledViewport.height;
            canvas.width = scaledViewport.width;
            const renderContext = { canvasContext: context, viewport: scaledViewport };
            await page.render(renderContext).promise;
        }

        async function displayPages(leftPageNum, rightPageNum) {
            const showCanvas = async (canvas, ctx, pageNum) => {
                if (pageNum > 0 && pageNum <= pdfDoc.numPages) {
                    canvas.style.display = 'block';
                    await renderPage(pageNum, canvas, ctx);
                } else {
                    canvas.style.display = 'none';
                }
            };
            await Promise.all([
                showCanvas(canvasLeft, ctxLeft, leftPageNum),
                showCanvas(canvasRight, ctxRight, rightPageNum)
            ]);
        }

        function updatePdfPages() {
            if (!pdfDoc) return;
            if (pdfDoc.numPages === 1) {
                displayPages(0, 1);
                return;
            }
            let leftPage = currentPage;
            let rightPage = currentPage + 1;
            if (leftPage === pdfDoc.numPages && pdfDoc.numPages % 2 !== 0) {
                 displayPages(leftPage, 0);
            } else {
                 displayPages(leftPage, rightPage);
            }
        }

        // --- Wavesurfer.js Setup ---
        const wavesurfer = WaveSurfer.create({
            container: '#waveform',
            waveColor: 'violet',
            progressColor: 'purple',
            mediaControls: false,
        });
        wavesurfer.load("{{ song.audio_file.url }}");
        document.getElementById('play-pause').addEventListener('click', () => {
            wavesurfer.playPause();
        });

        // --- Timings Logic ---
        function formatTime(seconds) {
            if (seconds === null || seconds === undefined) return '--:--:--';
            return new Date(seconds * 1000).toISOString().substr(11, 8);
        }

        function renderTimingsTable() {
            timingsTableBody.innerHTML = '';
            pageSettings.forEach(setting => {
                const row = document.createElement('tr');

                // Page Button
                const pageCell = document.createElement('td');
                const pageBtn = document.createElement('button');
                pageBtn.textContent = `P${setting.page}`;
                pageBtn.onclick = () => jumpToPage(setting.page);
                pageCell.appendChild(pageBtn);

                // Time Button
                const timeCell = document.createElement('td');
                const timeBtn = document.createElement('button');
                timeBtn.textContent = formatTime(setting.time);
                timeBtn.onclick = () => setTimeForPage(setting.page);
                timeCell.appendChild(timeBtn);

                // Status Button
                const statusCell = document.createElement('td');
                const statusBtn = document.createElement('button');
                const isSaved = setting.isSaved;
                statusBtn.textContent = isSaved ? '保存済み' : '未保存';
                if (!isSaved) {
                    statusBtn.classList.add('status-unsaved');
                }
                statusBtn.onclick = () => saveAllTimings();
                statusCell.appendChild(statusBtn);

                row.appendChild(pageCell);
                row.appendChild(timeCell);
                row.appendChild(statusCell);
                timingsTableBody.appendChild(row);
            });
        }

        function jumpToPage(pageNum) {
            const setting = pageSettings.find(s => s.page === pageNum);
            if (setting && setting.isSaved && setting.time !== null) {
                const duration = wavesurfer.getDuration();
                if (duration > 0) {
                    const progress = setting.time / duration;
                    wavesurfer.seekTo(progress);
                }
            }
        }

        function setTimeForPage(pageNum) {
            const setting = pageSettings.find(s => s.page === pageNum);
            if (setting) {
                setting.time = wavesurfer.getCurrentTime();
                setting.isSaved = false; // Mark as unsaved
                renderTimingsTable();
            }
        }

        function saveAllTimings() {
            // Create the array of timings for pages 2+ for the server
            const timingsToSave = pageSettings
                .filter(s => s.page > 1 && s.time !== null)
                .map(s => s.time)
                .sort((a, b) => a - b);

            fetch("{% url 'save_timings' score.id %}", {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': csrfToken
                },
                body: JSON.stringify({ timings: timingsToSave })
            }).then(response => response.json())
              .then(data => {
                  if (data.status === 'success') {
                      alert('Timings saved!');
                      // Update the state to reflect that all are saved
                      pageSettings.forEach(s => {
                          // A time is considered 'saved' if it has a value.
                          // P1 is always saved. Others are saved if they have a time set.
                          if (s.time !== null) {
                              s.isSaved = true;
                          }
                      });
                      renderTimingsTable();
                  } else {
                      alert('Error saving timings.');
                  }
              });
        }

        // --- Syncing Logic ---
        function updatePageForTime(currentTime) {
            let newPage = 1;
            const sortedTimings = pageSettings
                .filter(s => s.isSaved && s.time !== null)
                .sort((a, b) => a.time - b.time);

            for (const setting of sortedTimings) {
                // Add a small tolerance (e.g., 50ms) to handle floating point inaccuracies
                if (currentTime + 0.05 >= setting.time) {
                    newPage = setting.page;
                }
            }

            if (newPage !== currentPage) {
                currentPage = newPage;
                updatePdfPages();
            }
        }

        wavesurfer.on('audioprocess', (currentTime) => {
            updatePageForTime(currentTime);
        });

        // Also update page when user seeks by clicking on the waveform
        wavesurfer.on('seek', (progress) => {
            const currentTime = wavesurfer.getDuration() * progress;
            updatePageForTime(currentTime);
        });

        // Add a click handler to ensure page updates when clicking on the waveform while paused.
        wavesurfer.on('click', (progress) => {
            const currentTime = wavesurfer.getDuration() * progress;
            updatePageForTime(currentTime);
        });
        
        // --- Initial Load ---
        wavesurfer.on('ready', () => {
            pdfjsLib.getDocument(pdfUrl).promise.then(doc => {
                pdfDoc = doc;
                
                // Initialize pageSettings
                for (let i = 1; i <= pdfDoc.numPages; i++) {
                    let time = null;
                    let isSaved = false;
                    if (i === 1) {
                        time = 0;
                        isSaved = true;
                    } else if (serverTimings[i - 2] !== undefined) {
                        time = serverTimings[i - 2];
                        isSaved = true;
                    }
                    pageSettings.push({ page: i, time: time, isSaved: isSaved });
                }

                currentPage = 1;
                updatePdfPages();
                renderTimingsTable();
            });
        });
    </script>
</body>
</html>
        
